package main

import "fmt"

/*
EX-010: Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89. By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms. (Euler Projects #2)
*/

/*
1) Understanding the problem: The problem is stating that we need to calculate the summation of all the even-valued numbers in a fibonacci sequence that do not exceed 4 million, simple as that. Basically, we need to write an algorithm to calculate the next fibonacci number, considering that we're starting from 1 and 2 ... and so on. Then, if that value is even, sum it up with the previous one and at last, return the summation. We need a loop to find out fibonacci numbers that do not exceed 4 million, and a selection statement to consider the numbers being even or odd to behave accordingly.

2) Algorithm:
	inputs: 1, 2 as the starting points of fibonacci sequence and the limit of 4,000,000.
	outputs: sum (uint - I guess it would be bigger than 32bit numbers)
	algorithm:
		- Have a variable named sum (uint) for summation.
		- Write a loop to calculate the next fibonacci number, considering 1 and 2 as the starting point.
		- With calculating each next number, if it's even, add it to the summation.
		- When the next number was above 4 million, stop the loop.
		- Return the summation.
3) Flowchart attached.
4) Pseudo code =>
	- sum = 0 (uint), i = 1, j = 2, next = i + j
	- for next < 4000000 { if next % 2 == 0 then sum += next else continue to the next iteration }
	- once the loop ended, return the sum
5) Actual code below:
*/

func main() {
	// Normal way:
	// var sum uint32
	// var i uint32 = 1
	// var j uint32 = 2

	// for ; j < 4_000_000; i, j = j, i+j {
	// 	if j&1 == 0 {
	// 		sum += j
	// 	}
	// }

	// fmt.Println(sum)

	// Faster way:
	var sum uint = 0
	var a uint = 2
	var b uint = 8

	for a < 4_000_000 {
		sum += a
		a, b = b, 4*b+a
	}

	fmt.Println(sum)
}

/*
6) Testing: it was a calculation process, no testing needed!
*/

/*
7) Maintenance:
	- Can I improve the performance? Yes, by using j&1 instead of j%2, performance would be increased, if the compiler's not doing it already. Moreover, there's a formula for calculating the next even fibonacci number. If we look closely, every 3rd number in the sequence is even by default (4*j+i), so if we say that i is the first even number which is 2, and j is the second even number which is 8, we can use the given formula to calculate the next even number in the sequence; and we don't even need selection anymore (if/else). This is much more faster by requires mathematical knowledge.
	- Can I make the code cleaner/more readable? The code is already clean and readable, i and j variables could be inside the loop but since we want to have the best performance and memory consumption, even those 4 bytes (refer to the ex-009) are important, so here we are, declaring with types outside of the loop. Also it turned out that 32bits are enough, since I though the summation would result in a much bigger number, but nah.
	- Document anything I change later on for making this code better.
*/

// Takeaway: We don't need a third variable to find out the next fibonacci number; using the first two and switching their positions are enough to calculate; it's a mistake and clearly an overkill to use another variable to calculate the "next" number in a sequence. Since these questions are mathematical, there are actually wise mathematical ways to calculate faster than the code above which we talked about.
